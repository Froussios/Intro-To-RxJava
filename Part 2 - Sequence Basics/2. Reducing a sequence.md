# Ограничение последовательностей

Примеры которые мы видели до этого были достаточно малы. Ничто не должно удержать вас от использования Rx при больших объемах реальных данных, но что хорошего в Rx если он выбросит на вас весь обьем данных, и оставит вас разбираться с этим? Здесь мы разберем операторы которые помогут отфильтровать ненужные данные, или сократить последовательность к единому нужному вам значению.

Большинство операторов представлены тут будут знакомы тем кто работал с Java's `Stream’s` или функциональным программированием. Все операторы возвращают новый объект Observable и _не_ влияет на оригинальный Observable. Этот принцип является ключевым в Rx. Преобразование Observable приводит к созданию нового Observable, оригинальный объект остается незатронутым. Подписчики(Subscribers) оригинального объекта не должны заметить никаких изменений, но как мы увидим дальше гарантирование этого принципа требует также осторожности от разработчика. 

### Marble diagrams (Мраморная диаграмма?)

Это подходящий момент представить представить концепцию мраморных диаграмм. Это популярный метод объяснения работы операторов в Rx, так как он достаточно интуитивен и нагляден. Диаграммы присутствуют во многих местах документации к RxJava и есть смысл ознакомится с ними. Формат в основном описывает сам себя: время течет слева направо, фигуры представляют собой данные, прямая(‘|’) - onCompletion, Х - ошибка. Оператор применяется в верхней последовательности
и возвращает последовательность снизу.  

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/legend.png)

## Filter

`filter` - принимает функцию предикат которая рассчитывает и возвращает истинна или лож для каждого испущенного элемента. Если  решение ложно(`false`) элемент отбрасывается из фильтруемой последовательности.

```java
public final Observable<T> filter(Func1<? super T,java.lang.Boolean> predicate)
```

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/filter.png)

Отфильтруем последовательность чисел и оставим в ней только четные числа.

```java
Observable<Integer> values = Observable.range(0,10);
Subscription oddNumbers = values
	.filter(v -> v % 2 == 0)
	.subscribe(
	    v -> System.out.println(v),
	    e -> System.out.println("Error: " + e),
	    () -> System.out.println("Completed")
	);
```

[Вывод](/tests/java/itrx/chapter2/reducing/FilterExample.java)
```
0
2
4
6
8
Completed
```

## distinct и distinctUntilChanged

`distinct` - отбрасывает элементы которые уже встречались в последовательности.

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinct.png)

```java
Observable<Integer> values = Observable.create(o -> {
	o.onNext(1);
	o.onNext(1);
	o.onNext(2);
	o.onNext(3);
	o.onNext(2);
	o.onCompleted();
});

Subscription subscription = values
	.distinct()
	.subscribe(
	    v -> System.out.println(v),
	    e -> System.out.println("Error: " + e),
	    () -> System.out.println("Completed")
	);
```
[Вывод](/tests/java/itrx/chapter2/reducing/DistinctExample.java)
```
1
2
3
Completed
```

Перегрузка `distinct` принимает селектор ключа. Для каждого элемента функция создает ключ который используется для сравнения уже встреченных элементов.

```java
public final <U> Observable<T> distinct(Func1<? super T,? extends U> keySelector)
```

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinct.key.png)

В этом примере используем первую букву в качестве ключа.

```java
Observable<String> values = Observable.create(o -> {
	o.onNext("First");
	o.onNext("Second");
	o.onNext("Third");
	o.onNext("Fourth");
	o.onNext("Fifth");
	o.onCompleted();
});

Subscription subscription = values
	.distinct(v -> v.charAt(0))
	.subscribe(
	    v -> System.out.println(v),
	    e -> System.out.println("Error: " + e),
	    () -> System.out.println("Completed")
	);
```
[Вывод](/tests/java/itrx/chapter2/reducing/DistinctExample.java)
```
First
Second
Third
Completed
```

"Fourth" и "Fifth" были отброшены так как начинаются с ‘F’, а этот ключ встречался в "First".

Опытные программисты знают что этот оператор сохраняет каждый уникальный элемент во внутреннем списке который прошел через Observable и сравнивает новые элементы с этим списком. Rx аккуратно скрывает такие вещи, вы должны быть в курсе, что это может привести в значительным затратам.

Разновидность `distinct` - `distinctUntilChanged`. Разница заключается в том, что последовательные не уникальные значения отбрасываются.

```java
public final Observable<T> distinctUntilChanged()
public final <U> Observable<T> distinctUntilChanged(Func1<? super T,? extends U> keySelector)
```

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinctUntilChanged.png)

```java
Observable<Integer> values = Observable.create(o -> {
	o.onNext(1);
	o.onNext(1);
	o.onNext(2);
	o.onNext(3);
	o.onNext(2);
	o.onCompleted();
});

Subscription subscription = values
	.distinctUntilChanged()
	.subscribe(
	    v -> System.out.println(v),
	    e -> System.out.println("Error: " + e),
	    () -> System.out.println("Completed")
	);
```
[Вывод](/tests/java/itrx/chapter2/reducing/DistinctExample.java)
```
1
2
3
2
Completed
```

Вы также можете использовать селектор ключа с `distinctUntilChanged`.

```java
Observable<String> values = Observable.create(o -> {
    o.onNext("First");
    o.onNext("Second");
    o.onNext("Third");
    o.onNext("Fourth");
    o.onNext("Fifth");
    o.onCompleted();
});

Subscription subscription = values
    .distinctUntilChanged(v -> v.charAt(0))
    .subscribe(
    	    v -> System.out.println(v),
    	    e -> System.out.println("Error: " + e),
    	    () -> System.out.println("Completed")
    	);
```
[Вывод](/tests/java/itrx/chapter2/reducing/DistinctExample.java)
```
First
Second
Third
Fourth
Completed
```

## ignoreElements

`ignoreElements` - игнорирует каждое значение но пропускает `onCompleted` и `onError`.

```java
Observable<Integer> values = Observable.range(0, 10);

Subscription subscription = values
	.ignoreElements()
	.subscribe(
	    v -> System.out.println(v),
	    e -> System.out.println("Error: " + e),
	    () -> System.out.println("Completed")
	);
```
[Вывод](/tests/java/itrx/chapter2/reducing/IgnoreExample.java)
```
Completed
```

`ignoreElements()` - производит такой же результат что и `filter(v -> false)`


## skip и take

Следующая группа элементов служит для обрезания последовательности в определенной точке базируясь на индексе элемента, и возвращает либо первую либо вторую часть. `take` берет первые n элементов, когда `skip` пропускает их. Обратите внимание, что ни одна из последовательностей не считает ошибкой если количество элементов в ней меньше указанного индекса.

```java
Observable<T> 	take(int num)
```

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/take.png)

```java
Observable<Integer> values = Observable.range(0, 5);

Subscription first2 = values
	.take(2)
	.subscribe(
	    v -> System.out.println(v),
	    e -> System.out.println("Error: " + e),
	    () -> System.out.println("Completed")
	);
```

[Вывод](/tests/java/itrx/chapter2/reducing/TakeSkipExample.java)
```
0
1
Completed
```

Пользователи потоков из Java 8 должны знать оператор `take` как `limit`. Оператор `limit` также присутствует в Rx для тех же целей. Это синоним для `take`, но ему не достаёт перегрузок которые мы скоро увидем.

`take` - завершится как только получит n-й элемент. Если произойдет ошибка, она будет пробоброшена в том случае если она произошла до n-го элемента. `take` - не заботится о том что произошло с Observable после n-го элемента.

```java
Observable<Integer> values = Observable.create(o -> {
	o.onNext(1);
	o.onError(new Exception("Oops"));
});

Subscription subscription = values
	.take(1)
	.subscribe(
	    v -> System.out.println(v),
	    e -> System.out.println("Error: " + e),
	    () -> System.out.println("Completed")
	);
```
[Вывод](/tests/java/itrx/chapter2/reducing/TakeSkipExample.java)
```
1
Completed
```

`skip` returns the other half of a `take`.

```java
Observable<T> 	skip(int num)
```

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skip.png)

```java
Observable<Integer> values = Observable.range(0, 5);

Subscription subscription = values
	.skip(2)
	.subscribe(
	    v -> System.out.println(v),
	    e -> System.out.println("Error: " + e),
	    () -> System.out.println("Completed")
	);
```
[Вывод](/tests/java/itrx/chapter2/reducing/TakeSkipExample.java)
```
2
3
4
Completed
```

Есть перегрузки кода последовательность обрезается в определенный момент времени а не на конкретном элементе.

```java
Observable<T> 	take(long time, java.util.concurrent.TimeUnit unit)
Observable<T> 	skip(long time, java.util.concurrent.TimeUnit unit)
```

```java
Observable<Long> values = Observable.interval(100, TimeUnit.MILLISECONDS);

Subscription subscription = values
	.take(250, TimeUnit.MILLISECONDS)
	.subscribe(
	    v -> System.out.println(v),
	    e -> System.out.println("Error: " + e),
	    () -> System.out.println("Completed")
	);
```
[Вывод](/tests/java/itrx/chapter2/reducing/TakeSkipExample.java)
```
0
1
Completed
```

## skipWhile and takeWhile

`take` и `skip` с предопределенными индексами. Если вам нужно найти точку отсечения основываясь на входных данных используйте `takeWhile` и `skipWhile`. `takeWhile` получает значение пока функция предикат возвращает истину.

```java
Observable<T> 	takeWhile(Func1<? super T,java.lang.Boolean> predicate)
```

```java
Observable<Long> values = Observable.interval(100, TimeUnit.MILLISECONDS);

Subscription subscription = values
	.takeWhile(v -> v < 2)
	.subscribe(
	    v -> System.out.println(v),
	    e -> System.out.println("Error: " + e),
	    () -> System.out.println("Completed")
	);
```
[Вывод](/tests/java/itrx/chapter2/reducing/TakeSkipExample.java)
```
0
1
Completed
```

Как и ожидалось, `skipWhile` вернет вторую половину последовательности

```java
Observable<Long> values = Observable.interval(100, TimeUnit.MILLISECONDS);

Subscription subscription = values
	.skipWhile(v -> v < 2)
	.subscribe(
	    v -> System.out.println(v),
	    e -> System.out.println("Error: " + e),
	    () -> System.out.println("Completed")
	);
```
[Вывод](/tests/java/itrx/chapter2/reducing/TakeSkipExample.java)
```
2
3
4
...
```

## skipLast и takeLast

`skipLast` и `takeLast` работают также как `take` и `skip`, с тем отличием, что точка отсечения отсчитывается с конца.

```java
Observable<Integer> values = Observable.range(0,5);

Subscription subscription = values
	.skipLast(2)
	.subscribe(
	    v -> System.out.println(v),
	    e -> System.out.println("Error: " + e),
	    () -> System.out.println("Completed")
	);
```
[Вывод](/tests/java/itrx/chapter2/reducing/TakeSkipExample.java)
```
0
1
2
Completed
```
К настоящему времени вы должны догадаться как соотносяться `takeLast` и `skipLast`. Также присутствуют перегрузки с индексами и со временем.


## takeUntil и skipUntil

Есть еще два метода - `takeUntil` и `skipUntil`. `takeUntil` работает точно так же как `takeWhile` за исключением он принимает элементы пока предикат ложный. Так же ведет себя и `skipUntil`.

Наряду с этим, `takeUntil` и` skipUntil` имеют очень интересную перегрузку. Точка отсечки определяется в момент, когда другой _Observable_ испускает элемент.

```java
public final <E> Observable<T> takeUntil(Observable<? extends E> other)
```

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeUntil.png)

```java
Observable<Long> values = Observable.interval(100,TimeUnit.MILLISECONDS);
Observable<Long> cutoff = Observable.timer(250, TimeUnit.MILLISECONDS);

Subscription subscription = values
	.takeUntil(cutoff)
	.subscribe(
	    v -> System.out.println(v),
	    e -> System.out.println("Error: " + e),
	    () -> System.out.println("Completed")
	);
```
[Вывод](/tests/java/itrx/chapter2/reducing/TakeSkipExample.java)
```
0
1
Completed
```
Как вы помните, `timer` ожидает 250мс и испускает одно событие. `takeUntil` реагирует на этот сигнал и останавливает последовательность. Обратите внимание что сигнал может быть любого типа, так как его значение не используется.

Еще раз `skipUntil` работает по тем же правилам и возвращает вторую половину последовательности. Элементы игнорируются пока не прийдет сигнал о начале трансляции элементов  насквозь.

```java
Observable<Long> values = Observable.interval(100,TimeUnit.MILLISECONDS);
Observable<Long> cutoff = Observable.timer(250, TimeUnit.MILLISECONDS);

Subscription subscription = values
	.skipUntil(cutoff)
	.subscribe(
	    v -> System.out.println(v),
	    e -> System.out.println("Error: " + e),
	    () -> System.out.println("Completed")
	);
```
[Вывод](/tests/java/itrx/chapter2/reducing/TakeSkipExample.java)
```
2
3
4
...
```


#### Продолжить

| Предыдущий | Следующий |
| --- | --- |
| [Creating a sequence](/Part 2 - Sequence Basics/1. Creating a sequence.md) | [Inspection](/Part 2 - Sequence Basics/3. Inspection.md) |
